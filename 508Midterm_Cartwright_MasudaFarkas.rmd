---
title: "Hedonic Home Price Prediction in Boulder County"
subtitle: "Team: Simon & Garfunkel Tribute Band"
author: "Alex Cartwright & Max Masuda-Farkas"
date: "22 October 2021"
output:
  html_document:
    toc: true
    toc_float: TRUE
    number_sections: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(tidycensus)
library(sf)
library(viridis)
library(spdep)
library(caret)
library(ckanr)
library(FNN)
library(grid)
library(gridExtra)
library(ggcorrplot)
library(kableExtra)
library(stargazer)

root.dir = "https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/"
source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")
palette5 <- c("#25CB10", "#5AB60C", "#8FA108",   "#C48C04", "#FA7800")

options(scipen = 999)
```

```{r, out.width = "400px", echo = FALSE}
knitr::include_graphics("Simon_and_Garfunkel_1968_poster.png")
```

# Data

-Briefly describe your methods for gathering the data.
-Present a table of summary statistics with variable descriptions. Sort these variables by
their category (internal characteristics, amenities/public services or spatial structure). Check out
the `stargazer` package for this.
-Present a correlation matrix
-Present 4 home price correlation scatterplots that you think are of interest. I’m going to
look for interesting open data that you’ve integrated with the home sale observations.
-Develop 1 map of your dependent variable (sale price)
-Develop 3 maps of 3 of your most interesting independent variables.
-Include any other maps/graphs/charts you think might be of interest.

```{r data wrangling, include = FALSE, message = FALSE, warning = FALSE}
# ----- create boulder_homes geojson dataset, convert to sf, condition data -----
boulder_homes <- 
  st_read("studentData.geojson", crs = 'ESRI:102254') %>%
  mutate(price_per_sf = price / TotalFinishedSF) %>%
  mutate(Age = 2021 - builtYear)

boulder_homes$AcDscr = ifelse(is.na(boulder_homes$Ac) | 
                              boulder_homes$Ac == 200,
                              "No AC", boulder_homes$AcDscr)

# There are a dozen or so home records with 1 or 0 sq.ft. of finished area.
# These records are removed because they are not representative of the full data.
boulder_homes <- boulder_homes %>%
  dplyr::filter(TotalFinishedSF > 1)

boulder_boundary <-
  st_read("County_Boundary.geojson") %>%
  st_transform('ESRI:102254')

# ----- Census Data Wrangling -----
var19 <- load_variables(2019, "acs5", cache = TRUE)

acs_vars <- c(
  "B19013_001E", # Med HH Income
  "B06010_001E", # total earners
  "B06010_011E", # number of earners making over $75K
  "C24070_001E", # Labor force
  "C24070_002E", # Agriculture, forestry, fishing and hunting, and mining
  "C24070_003E", # Construction
  "C24070_004E", # Manufacturing
  "C24070_005E", # Wholesale trade
  "C24070_006E", # Retail trade
  "C24070_007E", # Transportation and warehousing, and utilities
  "C24070_008E", # Information
  "C24070_009E", # Finance and insurance, and real estate, and rental and leasing
  "C24070_010E", # Professional, scientific, and management, and administrative, and waste management services
  "C24070_011E", # Educational services, and  health care and social assistance
  "C24070_012E") # Arts, entertainment, and recreation, and accommodation and food services

acsTractsBoulder.2019.sf <- get_acs(geography = "tract",
                                   year = 2019, 
                                   variables = acs_vars, 
                                   geometry = TRUE, 
                                   state = "CO", 
                                   county = "Boulder", 
                                   output = "wide") %>%
  st_transform('ESRI:102254')

acsTractsBoulder.2019.sf <- acsTractsBoulder.2019.sf %>%
  dplyr::select(GEOID, NAME, all_of(acs_vars)) %>%
  rename(med_HH_Income = B19013_001E,
         tot_earners = B06010_001E,
         over75K = B06010_011E,
         employed = C24070_001E,
         Ag_Mining = C24070_002E,
         Construction = C24070_003E,
         Manufacturing = C24070_004E,
         Wholesale = C24070_005E,
         Retail = C24070_006E,
         Transportation = C24070_007E,
         Information = C24070_008E,
         Finance = C24070_009E,
         Professional = C24070_010E,
         Ed_Health = C24070_011E,
         ArtsRecEnt = C24070_012E) %>%
  mutate(
         pct.over75K = over75K/tot_earners,
         pct.Ag_Mining = Ag_Mining/employed,
         pct.Construction = Construction/employed,
         pct.Manufacturing = Manufacturing/employed,
         pct.Wholesale = Wholesale/employed,
         pct.Retail = Retail/employed,
         pct.Transportation = Transportation/employed,
         pct.Information = Information/employed,
         pct.Finance = Finance/employed,
         pct.Professional = Professional/employed,
         pct.Ed_Health = Ed_Health/employed,
         pct.ArtsRecEnt = ArtsRecEnt/employed)

censusFactors <- acsTractsBoulder.2019.sf %>%
  select(med_HH_Income, pct.over75K, pct.Information, pct.Finance, pct.Professional,
         pct.Ed_Health)

boulder_homes <-
  st_join(boulder_homes, censusFactors)

# ----- Front Range polyline factor -----

FrontRange = st_read("FrontRange.shp") %>%
  st_transform('ESRI:102254')

boulder_homes <- boulder_homes %>%
  mutate(dist_FR = as.numeric(st_distance(., FrontRange)))

# ----- Municipal Boundaries of Boulder County -----
munis <- st_read("https://opendata.arcgis.com/datasets/9597d3916aba47e887ca563d5ac15938_0.geojson") %>%
  st_transform('ESRI:102254') %>%
  dplyr::select(ZONEDESC, geometry) %>%
  rename(Municipality = ZONEDESC)

boulder_homes <-
  st_join(boulder_homes, munis)

boulder_homes$Municipality = ifelse(is.na(boulder_homes$Municipality),
                              "Not Incorporated", boulder_homes$Municipality)

# ----- Zip Codes of Boulder County -----
boulder_zips <-
  st_read("https://opendata.arcgis.com/datasets/6b6091f299204e4c9c406a624baf43e6_10.geojson") %>%
  st_transform('ESRI:102254') %>%
  st_intersection(boulder_boundary, boulder_zips) %>%
  # filter only zip codes and geometry
  dplyr::select(GEOID10, geometry) %>%
  rename(ZipCode = GEOID10)

boulder_homes <-
  st_join(boulder_homes, boulder_zips)

# ----- School Data Wrangling -----
boulder_schools <-
  st_read("./colorado_schools.geojson") %>%
  st_transform('ESRI:102254') %>%
  st_intersection(boulder_boundary, boulder_schools) %>%
  filter(Type_ %in% c("Non-Public School Mailing Address",
         "Public School Physical Address"))

group_by(boulder_schools, Type_) %>%
  summarize(count = n())

st_c <- st_coordinates

boulder_homes <-
  boulder_homes %>% 
    mutate(
      schools_nn3 = nn_function(st_c(boulder_homes), st_c(boulder_schools), 3))

# ----- Trailheads Data Wrangling -----
trailheads <-
  st_read("https://opendata.arcgis.com/datasets/3a950053bbef46c6a3c2abe3aceee3de_0.geojson") %>%
  st_transform('ESRI:102254') %>%
  st_intersection(boulder_boundary, trailheads)

boulder_homes <- boulder_homes %>% 
    mutate(
      trailheads_nn5 = nn_function(st_c(boulder_homes), st_c(trailheads), 5))
```

```{r split dataset into observed and predict, include = FALSE}
boulder_homes_observed <- boulder_homes %>%
  dplyr::filter(toPredict == 0)

boulder_homes_predict <- boulder_homes %>%
  dplyr::filter(toPredict == 1)
```

```{r build the model dataset, include=FALSE}
# Select variables from boulder_homes_observed 
feature_list <-
  c("price", "med_HH_Income", "pct.over75K", "pct.Information", "pct.Finance",
    "pct.Professional","pct.Ed_Health", "nbrBedRoom", "nbrFullBaths",
    "TotalFinishedSF", "AcDscr", "Age", "schools_nn3", "trailheads_nn5", "dist_FR",
    "qualityCodeDscr", "designCodeDscr", "ZipCode", "Municipality")

boulder.sf <- boulder_homes_observed %>% 
  select(feature_list)
```

## Regression Summary Statistics

```{r regression 1, include=FALSE, message=FALSE, warning=FALSE, echo=TRUE}
reg1 <- lm(price ~ ., data = st_drop_geometry(boulder.sf) %>%
             dplyr::select("price", "med_HH_Income", "pct.over75K", "pct.Information",
                           "pct.Finance", "pct.Professional","pct.Ed_Health",
                           "nbrBedRoom", "nbrFullBaths","TotalFinishedSF", "AcDscr",
                           "Age", "schools_nn3", "trailheads_nn5", "dist_FR", 
                           "qualityCodeDscr", "designCodeDscr", "ZipCode"))
```

The summary statistics of the full model are presented below.

```{r summary of reg1, results="asis", message=FALSE, echo=FALSE}
# summarytable1 <- data.frame(stargazer(reg1, type = "text"))

stargazer(reg1, type = "html")
```

## Correlation Matrix

What is the use of a correlation matrix? What correlations do we see?

``` {r correlation matrix, include=TRUE, warning=FALSE, message=FALSE}
numericVars <- 
  select_if(st_drop_geometry(boulder.sf), is.numeric) %>% na.omit()

ggcorrplot(
  round(cor(numericVars), 1), 
  p.mat = cor_pmat(numericVars),
  colors = c("#25CB10", "white", "#FA7800"),
  type="lower",
  insig = "blank") +   
    labs(title = "Correlation across numeric variables",
         caption = "Figure 1.1")
```

## Variable Correlation Scatterplots

What are the factors? Why did we choose them? What trends do we see?

```{r numerical variable scatterplots, include=TRUE, warning=FALSE, message=FALSE}
st_drop_geometry(boulder.sf) %>%
  dplyr::select(price, pct.over75K, pct.Professional, schools_nn3, trailheads_nn5) %>%
  filter(price <= 4000000) %>%
  gather(Variable, Value, -price) %>% 
   ggplot(aes(Value, price)) +
     geom_point(size = .5) + geom_smooth(method = "lm", se=F, colour = "#FA7800") +
     facet_wrap(~Variable, ncol = 2, scales = "free") +
     labs(title = "Price as a function of continuous variables",
          caption = "Figure 1.2") +
     plotTheme()
```

## Spatial Distribution of Home Sale Prices in Boulder County

```{r sale price map}
# Price per square foot
ggplot() +
  geom_sf(data = boulder_boundary, fill = NA, colour = "black") +
  geom_sf(data = boulder.sf, aes(colour = q5(price)), 
          show.legend = "point", size = .75) +
  scale_colour_manual(values = palette5,
                   labels=qBr(boulder.sf,"price"),
                   name="Quintile\nBreaks") +
  labs(title="Home Sale Prices, Boulder County",
       caption = "Figure 1.3") +
  mapTheme()
```

## Mapping Independent Variables

```{r map of distance from front range}
# Distance from the Front Range
ggplot() +
  geom_sf(data = boulder_boundary, fill = NA, colour = "black") +
  geom_sf(data = FrontRange, colour = "#2d6a4f", size = 2) +
  geom_sf(data = boulder_homes_observed, aes(colour = q5(dist_FR)), 
          show.legend = "point", size = .75) +
  scale_colour_manual(values = palette5,
                   labels=qBr(boulder_homes,"dist_FR"),
                   name="Quintile\nBreaks") +
  labs(title="Home distance from Front Range",
       caption = "Figure 1.4") +
  mapTheme()
```

```{r map of medHHincome}
# Median Household Income in Boulder County
ggplot() + 
  geom_sf(data = boulder_boundary, fill = NA, colour = "black") +
  geom_sf(data = acsTractsBoulder.2019.sf, aes(fill = med_HH_Income)) +
  scale_fill_viridis_b() +
  labs(title = "Median Household Income in Boulder County",
       subtitle = "by Census Tract",
       caption = "Figure 1.5") +
  mapTheme()
```

```{r map of schools in Boulder County}
# Distance from the Front Range
ggplot() +
  geom_sf(data = boulder_boundary, fill = NA, colour = "black") +
  geom_sf(data = boulder_schools, colour = "#2d6a4f") +
  labs(title = "Schools in Boulder County",
       caption = "Figure 1.6") +
  mapTheme()
```

```{r sale price and zip codes}
# Sale Price + zipcodes
ggplot() +
  geom_sf(data = boulder_boundary, fill = NA, colour = "black") +
  geom_sf(data = acsTractsBoulder.2019.sf, fill = NA, colour = "#55286F") +
  geom_sf(data = boulder_homes_observed, aes(colour = q5(price)), 
          show.legend = "point", size = .75) +
  scale_colour_manual(values = palette5,
                   labels=qBr(boulder_homes,"price"),
                   name="Quintile\nBreaks") +
  labs(title="Home Sale Prices + Zip Code Areas",
       caption = "Figure 1.7") +
  mapTheme()
```

# Methods

Briefly describe your method (remember who your audience is).

# Results

```{r PartionData, include=FALSE, warning=FALSE, message=FALSE}
inTrain <- createDataPartition(y = paste(boulder.sf$qualityCodeDscr, boulder.sf$designCodeDscr, boulder.sf$ZipCode, boulder.sf$AcDscr),
                               p = 0.75, list = FALSE)

boulder.training <- boulder.sf[inTrain,]
boulder.test <- boulder.sf[-inTrain,]

reg.training <- lm(price ~ ., data = as.data.frame(boulder.training) %>%
                  dplyr::select("price", "med_HH_Income", "pct.over75K", "pct.Information","pct.Finance", "pct.Professional","pct.Ed_Health",
                           "nbrBedRoom", "nbrFullBaths","TotalFinishedSF", "AcDscr",
                           "Age", "schools_nn3", "trailheads_nn5", "dist_FR", 
                           "qualityCodeDscr", "designCodeDscr", "ZipCode"))
```

The following summary table presents the results of the linear regression on the training data set.

```{r summary of training regression, results="asis", message=FALSE, echo=FALSE}
stargazer(reg.training, type = "html")
```

## Test Set Results

```{r predict on test set, include=FALSE, warning=FALSE, message=FALSE}
boulder.test <-
  boulder.test %>%
  mutate(Regression = "Baseline Regression",
         price.predict = predict(reg.training, boulder.test),
         price.error = price.predict - price,
         price.abserror = abs(price.predict - price),
         price.ape = (abs(price.predict - price)) / price.predict)%>%
  filter(price < 5000000)
```

A summary of the mean absolute error and mean average percent error (MAPE) for the price prediction on the test data set is shown below.

``` {r summary statistics for test set, include = FALSE, warning=FALSE, message=FALSE}
mean(boulder.sf$price, na.rm = T)
test.MAE <- c(mean(boulder.test$price.abserror, na.rm = T))
test.MAPE <- c(mean(boulder.test$price.ape, na.rm = T))
test.SumStats <- data.frame(test.MAE, test.MAPE) 

test.SumStats %>%
  kable(col.names = c("MAE", "MAPE"), caption = "Test Set Error Metrics")
```

Graphic representations of the results of the test set prediction are shown below.

```{r ACCURACY//visualize, include=TRUE, warning=FALSE, message=FALSE}
# histogram of absolute errors
ggplot(boulder.test, aes(x = price.abserror)) +
  geom_histogram(binwidth=10000, fill = "green", colour = "white") +
  scale_x_continuous(limits = c(0, 1000000)) +
  labs(title = "Distribution of prediction errors for single test",
       x = "Sale Price Absolute Error", y = "Count") +
  plotTheme()
```

## Cross Validation Results

```{r cross validation, include=TRUE, warning=FALSE, message=FALSE}
fitControl <- trainControl(method = "cv", number = 100)
set.seed(825)

reg.cv <- 
  train(price ~ ., data = st_drop_geometry(boulder.sf), 
     method = "lm", trControl = fitControl, na.action = na.pass)
```

K-fold cross validation with 100 folds is used to explore the generalizability of this model. A histogram of the mean average error across the 100 folds is shown below.

```{r exploring cross validation results, include=TRUE, warning=FALSE, message=FALSE}
# histogram of cross validation MAE
mae <- data.frame(reg.cv$resample[,3]) %>%
  rename(mae = reg.cv.resample...3.)

ggplot(mae, aes(x = mae)) +
  geom_histogram(binwidth=10000, fill = "orange", colour = "white") +
  scale_x_continuous(labels = c(0, 100000, 200000, 300000, 400000, 500000), 
                     limits = c(0, 500000)) +
  labs(title = "Distribution of MAE",
       subtitle = "k-fold cross validation; k = 100",
       x = "Mean Absolute Error", y = "Count") +
  plotTheme()
```

The prices predicted for the test set are plotted against the actual sale prices for the test set in the figure below.

```{r predicted vs observed, include=TRUE, message=FALSE}
ggplot(boulder.test) +
  geom_point(aes(price, price.predict)) +
  geom_smooth(aes(price, price), colour = "orange") +
  geom_smooth(method = "lm", aes(price, price.predict), se = FALSE, colour = "green") +
  labs(title = "Predicted sale price as a function of observed price",
       subtitle = "Orange line represents a perfect prediction; Green line represents prediction",
       x = "Observed Sale Price", y = "Predicted Sale Price") +
  plotTheme()
```

Map of residual absolute errors for the test set

```{r test set residual errors, include = TRUE}
ggplot() +
  geom_sf(data = boulder_boundary, fill = "grey") +
  geom_sf(data = boulder.test, aes(colour = q5(price.abserror)), 
          show.legend = "point", size = .75) +
  scale_colour_manual(values = palette5,
                   labels=qBr(boulder.test,"price.abserror"),
                   name="Quintile\nBreaks") +
  labs(title="Test set absolute price errors",
       caption = "Figure X.X") +
  mapTheme()
```

Plot of the spatial lag in errors for the test set

``` {r spatial error lag, include=TRUE, warning=FALSE, message=FALSE}
coords.test <- st_coordinates(boulder.test) 

neighborList.test <- knn2nb(knearneigh(coords.test, 5))

spatialWeights.test <- nb2listw(neighborList.test, style="W")

boulder.test %>%
  mutate(lagPriceError = lag.listw(spatialWeights.test, price.error)) %>%
  ggplot(aes(lagPriceError, price.error)) +
     geom_point(size = .5) + geom_smooth(method = "lm", se=F, colour = "#FA7800") +
     labs(title = "Error as a function of the spatial lag of price errors") +
     plotTheme()
```

Plot of the Moran's I test on the test set

``` {r morans i, include=TRUE, warning=FALSE, message=FALSE}
moranTest <- moran.mc(boulder.test$price.error,
                      spatialWeights.test, nsim = 999)

ggplot(as.data.frame(moranTest$res[c(1:999)]), aes(moranTest$res[c(1:999)])) +
  geom_histogram(binwidth = 0.01) +
  geom_vline(aes(xintercept = moranTest$statistic), colour = "#FA7800",size=1) +
  scale_x_continuous(limits = c(-1, 1)) +
  labs(title="Observed and permuted Moran's I",
       subtitle= "Observed Moran's I in orange",
       x="Moran's I",
       y="Count") +
  plotTheme()
```

```{r all predicted values, include=TRUE}
allPredictions <- boulder_homes %>%
  mutate(predictions = predict(reg1, boulder_homes)) %>%
  dplyr::select(predictions)

ggplot() +
  geom_sf(data = boulder_boundary, fill = "grey") +
  geom_sf(data = allPredictions, aes(colour = q5(predictions)), 
          show.legend = "point", size = .75) +
  scale_colour_manual(values = palette5,
                   labels=qBr(allPredictions,"predictions"),
                   name="Quintile\nBreaks") +
  labs(title="Predictions for all homes in the dataset, Boulder County",
       caption = "Figure X.X") +
  mapTheme()
```

There is something so strange going on in this one zip code.

```{r map of MAPE by Zip Code}
st_drop_geometry(boulder.test) %>%
  group_by(ZipCode) %>%
  summarize(mean.MAPE = mean(price.ape, na.rm = T)) %>%
  ungroup() %>% 
  left_join(boulder_zips) %>%
    st_sf() %>%
    ggplot() + 
      geom_sf(aes(fill = mean.MAPE)) +
      geom_sf(data = boulder.test, colour = "black", size = .5) +
      scale_fill_gradient(low = palette5[1], high = palette5[5],
                          name = "MAPE") +
      labs(title = "Mean test set MAPE by Zip Code") +
      mapTheme()
```

We need the scatterplot of MAPE by zip of mean price by zip

```{r MAPE by zip vs mean price by zip}
testError_by_zips <-
left_join(
  st_drop_geometry(boulder.test) %>%
    group_by(ZipCode) %>%
    summarize(meanPrice = mean(price, na.rm = T)),
  st_drop_geometry(boulder.test) %>%
    group_by(ZipCode) %>%
    summarize(MAPE = mean(price.ape)))

testError_by_zips %>%
  kable() %>% kable_styling()
```

```{r map of test errors by zip, warning=FALSE, message=FALSE}
ggplot(testError_by_zips) +
  geom_point(aes(meanPrice, MAPE)) +
  geom_smooth(method = "lm", aes(meanPrice, MAPE), se = FALSE, colour = "green") +
  labs(title = "MAPE by Zip Code as a function of mean price by Zip Code",
       x = "Mean Home Price", y = "MAPE") +
  plotTheme()
```

## Generalizability

Is the model generalizable?

```{r generalizability, include=TRUE, warning=FALSE, message=FALSE}
boulder_tracts19 <- 
  get_acs(geography = "tract", year = 2019, 
          variables = c("B01001_001E","B01001A_001E","B06011_001"), 
          geometry = TRUE, state = "CO", county = "Boulder", output = "wide") %>%
  st_transform('ESRI:102254')  %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B01001A_001E,
         Median_Income = B06011_001E) %>%
  mutate(percentWhite = NumberWhites / TotalPop,
         raceContext = ifelse(percentWhite > .5, "Majority White", "Majority Non-White"),
         incomeContext = ifelse(Median_Income > 32322, "High Income", "Low Income"))

grid.arrange(ncol = 2,
  ggplot() + geom_sf(data = na.omit(boulder_tracts19), 
  aes(fill = raceContext)) +
    scale_fill_manual(values = c("#25CB10", "#FA7800"), name="Race Context") +
    labs(title = "Race Context") +
    mapTheme() + theme(legend.position="bottom"), 
  ggplot() + geom_sf(data = na.omit(boulder_tracts19), 
  aes(fill = incomeContext)) +
    scale_fill_manual(values = c("#25CB10", "#FA7800"), 
    name="Income Context") +
    labs(title = "Income Context") +
    mapTheme() + 
    theme(legend.position="bottom"))
```

# Discussion

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

Is this an effective model? What were some of the more interesting variables?
How much of the variation in prices could you predict? Describe the more important features?
Describe the error in your predictions? According to your maps, could you account the spatial
variation in prices? Where did the model predict particularly well? Poorly? Why do you think this
might be?

</div>

# Conclusion

Would you recommend your model to Zillow? Why or why not? How might you
improve this model?